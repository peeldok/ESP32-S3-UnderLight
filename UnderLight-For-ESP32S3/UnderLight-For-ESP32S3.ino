#include <FastLED.h>        
#include <Control_Surface.h>
#include <Preferences.h>

const byte _nLED = 32;
const byte _dLED = 14;
CRGB _LED[_nLED];
const uint8_t MAX_BRIGHTNESS = 255;

bool updateLED = false;
unsigned long lastUpdate = 0;
const unsigned long LED_UPDATE_INTERVAL = 10; 

Preferences prefs;

const byte _r[128] = {0, 28, 125, 255, 255, 255, 85, 24, 255, 255, 85, 36, 255, 255, 85, 24, 134, 81, 28, 16, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 134, 81, 24, 12, 255, 255, 85, 24, 255, 255, 85, 32, 255, 150, 117, 65, 0, 0, 0, 0, 0, 36, 125, 28, 255, 186, 174, 97, 12, 0, 0, 0, 61, 121, 174, 61, 255, 134, 113, 0, 57, 85, 53, 89, 49, 134, 210, 255, 255, 182, 142, 130, 57, 16, 12, 20, 20, 101, 166, 219, 215, 255, 158, 101, 28, 219, 125, 154, 142, 61, 113, 223, 158, 53, 24, 4, 182, 61, 178, 73};
const byte _g[128] = {0, 28, 125, 255, 73, 0, 0, 0, 186, 81, 28, 24, 255, 255, 85, 24, 255, 255, 85, 40, 255, 255, 85, 24, 255, 255, 85, 24, 255, 255, 85, 28, 255, 255, 85, 24, 194, 166, 65, 12, 134, 85, 28, 4, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 20, 53, 81, 97, 57, 85, 81, 0, 69, 0, 125, 28, 0, 255, 235, 255, 138, 255, 166, 40, 0, 0, 24, 32, 73, 223, 255, 255, 255, 255, 255, 138, 81, 125, 28, 0, 125, 174, 255, 89, 40, 73, 77, 20, 28, 57, 0, 81, 105, 223, 223, 178, 28, 255, 255, 150, 101, 61, 113, 255, 0, 0, 206, 65, 174, 49, 93, 20};
const byte _b[128] = {0, 28, 125, 255, 73, 0, 0, 0, 105, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 73, 0, 0, 0, 93, 24, 12, 0, 134, 85, 28, 16, 182, 150, 53, 16, 255, 255, 81, 24, 255, 255, 85, 24, 255, 255, 85, 24, 255, 255, 97, 45, 255, 255, 85, 24, 134, 81, 28, 16, 0, 0, 0, 0, 0, 53, 125, 255, 77, 202, 125, 28, 0, 45, 4, 8, 0, 134, 255, 255, 255, 255, 121, 0, 0, 4, 20, 0, 36, 109, 202, 255, 194, 231, 255, 89, 0, 0, 0, 4, 0, 12, 53, 40, 89, 24, 8, 61, 24, 36, 45, 12, 45, 105, 186, 255, 255, 61, 113, 255, 0, 0, 0, 0, 0, 0, 0, 0};

const byte _r2[128] = {0, 11, 44, 125, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
const byte _g2[128] = {0, 11, 44, 125, 255, 219, 186, 150, 117, 85, 53, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 69, 101, 134, 166, 198, 235, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 231, 219, 206, 194, 182, 170, 158, 146, 134, 121, 109, 97, 85, 73, 61, 49, 36, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 24, 36, 49, 61, 73, 85, 97, 109, 121, 134, 146, 158, 170, 182, 194, 206, 219, 231, 243, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
const byte _b2[128] = {0, 11, 44, 125, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 231, 219, 206, 194, 182, 170, 158, 146, 134, 121, 109, 97, 85, 73, 61, 49, 36, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 24, 36, 49, 61, 73, 85, 97, 109, 121, 134, 146, 158, 170, 182, 194, 206, 219, 231, 243, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 231, 219, 206, 194, 182, 170, 158, 146};

const byte _r3[128] = {0, 11, 44, 125, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
const byte _g3[128] = {0, 11, 44, 125, 255, 219, 186, 150, 117, 85, 53, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 69, 101, 134, 166, 198, 235, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 231, 219, 206, 194, 182, 170, 158, 146, 134, 121, 109, 97, 85, 73, 61, 49, 36, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 24, 36, 49, 61, 73, 85, 97, 109, 121, 134, 146, 158, 170, 182, 194, 206, 219, 231, 243, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
const byte _b3[128] = {0, 11, 44, 125, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 231, 219, 206, 194, 182, 170, 158, 146, 134, 121, 109, 97, 85, 73, 61, 49, 36, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 24, 36, 49, 61, 73, 85, 97, 109, 121, 134, 146, 158, 170, 182, 194, 206, 219, 231, 243, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 231, 219, 206, 194, 182, 170, 158, 146};

byte _r_web[3][128], _g_web[3][128], _b_web[3][128];

byte fullSysexBuffer[300];
int currentPos = 0;

USBMIDI_Interface midi;

void loadSavedPalettes() {
    prefs.begin("palettes", true);
    for (int i = 0; i < 3; i++) {
        String kr = "p" + String(i) + "r", kg = "p" + String(i) + "g", kb = "p" + String(i) + "b";
        if (prefs.isKey(kr.c_str())) prefs.getBytes(kr.c_str(), _r_web[i], 128);
        if (prefs.isKey(kg.c_str())) prefs.getBytes(kg.c_str(), _g_web[i], 128);
        if (prefs.isKey(kb.c_str())) prefs.getBytes(kb.c_str(), _b_web[i], 128);
    }
    prefs.end();
}

struct MyMIDI_Callbacks : FineGrainedMIDI_Callbacks<MyMIDI_Callbacks> {

    int getLedIndex(uint8_t p) {
        if (p >= 28 && p <= 35)      return 35 - p;
        else if (p >= 108 && p <= 115) return p - 100;
        else if (p >= 100 && p <= 107) return 131 - p;
        else if (p >= 116 && p <= 123) return p - 100;
        return -1;
    }

    void onNoteOn(Channel ch, uint8_t p, uint8_t v, Cable cable) {
        int ledIndex = getLedIndex(p);
        if (ledIndex >= 0 && ledIndex < _nLED) {
            uint8_t rawCh = ch.getRaw();
            if (rawCh == 0)      _LED[ledIndex] = CRGB(_r[v], _g[v], _b[v]);
            else if (rawCh == 1) _LED[ledIndex] = CRGB(_r2[v], _g2[v], _b2[v]);
            else if (rawCh == 2) _LED[ledIndex] = CRGB(_r3[v], _g3[v], _b3[v]);
            else if (rawCh >= 3 && rawCh <= 5) {
                uint8_t webIdx = rawCh - 3;
                _LED[ledIndex] = CRGB(_r_web[webIdx][v], _g_web[webIdx][v], _b_web[webIdx][v]);
            }
            updateLED = true;
        }
    }

    void onNoteOff(Channel ch, uint8_t p, uint8_t v, Cable cable) {
        int ledIndex = getLedIndex(p);
        if (ledIndex >= 0 && ledIndex < _nLED) {
            _LED[ledIndex] = CRGB::Black;
            updateLED = true;
        }
    }

    void onSysExMessage(MIDI_Interface &midi, SysExMessage sysex) {
        if (sysex.data[0] == 0xF0) {
            currentPos = 0;
            memset(fullSysexBuffer, 0, sizeof(fullSysexBuffer));
        }
        if (currentPos + sysex.length <= 300) {
            memcpy(&fullSysexBuffer[currentPos], sysex.data, sysex.length);
            currentPos += sysex.length;
        }
        if (sysex.data[sysex.length - 1] == 0xF7 || currentPos >= 261) {
            if (fullSysexBuffer[1] == 0x7D) {
                uint8_t pIdx = fullSysexBuffer[2];
                uint8_t cType = fullSysexBuffer[3];
                if (pIdx < 3) {
                    byte decoded[128];
                    for (int i = 0; i < 128; i++) {
                        decoded[i] = (fullSysexBuffer[4 + (i * 2)] << 7) | fullSysexBuffer[4 + (i * 2) + 1];
                    }
                    if (cType == 0)      memcpy(_r_web[pIdx], decoded, 128);
                    else if (cType == 1) memcpy(_g_web[pIdx], decoded, 128);
                    else if (cType == 2) memcpy(_b_web[pIdx], decoded, 128);
                    
                    String key = "p" + String(pIdx) + (cType == 0 ? "r" : (cType == 1 ? "g" : "b"));
                    prefs.begin("palettes", false);
                    prefs.putBytes(key.c_str(), decoded, 128);
                    prefs.end();
                }
            }
            currentPos = 0;
        }
    }
} callback;

void setup() {
    FastLED.addLeds<NEOPIXEL, _dLED>(_LED, _nLED);
    FastLED.setBrightness(MAX_BRIGHTNESS);
    loadSavedPalettes();
    midi.begin();
    midi.setCallbacks(callback);
}

void loop() {
    midi.update();
    unsigned long currentMillis = millis();
    if (updateLED && currentMillis - lastUpdate >= LED_UPDATE_INTERVAL) {
        FastLED.show();
        lastUpdate = currentMillis;
        updateLED = false;
    }
}
